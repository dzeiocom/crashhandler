package com.dzeio.crashhandler

import android.annotation.SuppressLint
import android.app.Application
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.os.Process
import android.util.Log
import android.widget.Toast
import androidx.annotation.StringRes
import androidx.core.content.edit
import com.dzeio.crashhandler.CrashHandler.Builder
import com.dzeio.crashhandler.ui.ErrorActivity
import com.dzeio.crashhandler.utils.ZipFile
import java.io.File
import java.io.IOException
import java.lang.Exception
import java.text.SimpleDateFormat
import java.util.Date
import java.util.TimeZone

/**
 * the Crash Handler class, you can get an instance by using it's [Builder]
 */
class CrashHandler private constructor(
    private val application: Application?,
    private val activity: Class<*>,
    private val prefs: SharedPreferences?,
    private val prefsKey: String?,
    @StringRes
    private val errorReporterCrashKey: Int?,
    private val prefix: String? = null,
    private val suffix: String? = null,
    private val exportFolder: File? = null
) {

    companion object {
        private const val TAG = "CrashHandler"
        private var instance: CrashHandler? = null

        /**
         * get the instance of the CrashHandler it will crash if it was not initialized previously
         */
        fun getInstance(): CrashHandler {
            if (this.instance == null) {
                throw Exception("can't get CrashHandler instance as its not initialized")
            }

            return this.instance!!
        }
    }

    /**
     * Builder for the crash handler
     */
    class Builder {
        private var application: Application? = null
        private var prefs: SharedPreferences? = null
        private var prefsKey: String? = null
        private var errorReporterCrashKey: Int? = null
        private var activity: Class<*>? = ErrorActivity::class.java
        private var prefix: String? = null
        private var suffix: String? = null
        private var exportLocation: File? = null

        /**
         * Change the Crash activity to with your own
         *
         * note: you can get the backtrace text by using `intent.getStringExtra("error")`
         *
         * @param context the context class to use
         */
        fun withContext(context: Context): Builder {
            this.application = context.applicationContext as Application?
            return this
        }

        /**
         * Change the Crash activity to with your own
         *
         * note: you can get the backtrace text by using `intent.getStringExtra("error")`
         *
         * @param activity the activity class to use
         */
        fun withActivity(activity: Class<*>): Builder {
            this.activity = activity
            return this
        }

        /**
         * [SharedPreferences] of your app to be able to handle ErrorActivity crashes
         *
         * note: you also need to use [withPrefsKey]
         *
         * @param prefs instance of [SharedPreferences] to use
         */
        fun withPrefs(prefs: SharedPreferences?): Builder {
            this.prefs = prefs
            return this
        }

        /**
         * the key of the [SharedPreferences] you want to let the library handle
         *
         * note: you also need to use [withPrefs]
         *
         * @param prefsKey the key to use
         */
        fun withPrefsKey(prefsKey: String?): Builder {
            this.prefsKey = prefsKey
            return this
        }

        /**
         * the resource key to use for the [Toast] if ErrorActivity crashed
         *
         * @param errorReporterCrashKey the string key to use
         */
        fun witheErrorReporterCrashKey(@StringRes errorReporterCrashKey: Int): Builder {
            this.errorReporterCrashKey = errorReporterCrashKey
            return this
        }

        /**
         * text to add after the "Crash report:" text and before the rest
         *
         * ex: "${BuildConfig.APPLICATION_ID} v${BuildConfig.VERSION_NAME} (${BuildConfig.VERSION_CODE})"
         *
         * @param prefix the text you add
         */
        fun withPrefix(prefix: String): Builder {
            this.prefix = prefix
            return this
        }

        /**
         * text to add after the content generated by the handler
         *
         * @param suffix the text
         */
        fun withSuffix(suffix: String): Builder {
            this.suffix = suffix
            return this
        }

        /**
         * Add a crash log export folder
         *
         * @param exportLocation the folder in which you want to export crash logs, it will be created if it does not exists
         */
        fun withExportLocation(exportLocation: File): Builder {
            this.exportLocation = exportLocation
            return this
        }

        /**
         * build the Crash Handler
         */
        fun build(): CrashHandler {
            return CrashHandler(
                application,
                activity!!,
                prefs,
                prefsKey,
                errorReporterCrashKey,
                prefix,
                suffix,
                exportLocation
            )
        }
    }

    init {
        instance = this
    }

    private var oldHandler: Thread.UncaughtExceptionHandler? = null

    fun setup() {
        if (application != null) {
            this.setup(application)
        }
    }

    /**
     * Destroy the handler
     */
    fun destroy() {
        if (oldHandler != null) {
            Thread.setDefaultUncaughtExceptionHandler(oldHandler)
        }
    }

    /**
     * Setup the crash handler, after this method is executed crashes should be handled through your
     * activity
     *
     * @param application the application instance to make sure everything is setup right
     */
    fun setup(application: Application) {
        // Application Error Handling
        oldHandler = Thread.getDefaultUncaughtExceptionHandler()
        Thread.setDefaultUncaughtExceptionHandler { paramThread, paramThrowable ->

            // Log error to logcat if it wasn't done before has it can not be logged depending on the version
            Log.e(TAG, "En error was detected", paramThrowable)

            // mostly unusable data but also log Thread Stacktrace
            Log.i(TAG, "Thread StackTrace:")
            for (item in paramThread.stackTrace) {
                Log.i(TAG, item.toString())
            }

            // get current time an date
            val now = Date().time
            var previousCrash: Long? = null

            // if lib as access to the preferences store
            if (prefs != null && prefsKey != null) {
                // get the last Crash
                previousCrash = prefs.getLong(prefsKey, 0L)

                // if a crash already happened just before it means the Error Activity crashed lul
                if (previousCrash >= now - 1000) {
                    // log it :D
                    Log.e(
                        TAG,
                        "Seems like the ErrorActivity also crashed, letting the OS handle it"
                    )

                    // try to send a toast indicating it
                    Toast.makeText(
                        application,
                        errorReporterCrashKey ?: R.string.crash_handler_reporter_crash,
                        Toast.LENGTH_LONG
                    ).show()

                    // Use the default exception handler
                    oldHandler?.uncaughtException(paramThread, paramThrowable)
                    return@setDefaultUncaughtExceptionHandler
                }

                // update the store
                prefs.edit(true) { putLong(prefsKey, now) }
            }

            Log.i(TAG, "Collecting Error")

            val data = this.buildData(
                now,
                previousCrash,
                paramThread,
                paramThrowable
            )

            try {
                exportData(data, now)
            } catch (e: IOException) {
                Log.e(TAG, "Could not export the data to file", e)
            }

            Log.i(TAG, "Starting ${activity.name}")

            // prepare the activity
            val intent = Intent(application, activity)

            // add flags so that it don't use the current Application context
            intent.addFlags(
                Intent.FLAG_ACTIVITY_CLEAR_TASK or
                    Intent.FLAG_ACTIVITY_NEW_TASK or
                    Intent.FLAG_ACTIVITY_CLEAR_TOP or
                    Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
            )

            // add the Data String
            intent.putExtra("error", data)

            // Start the activity
            application.startActivity(intent)
            Log.i(TAG, "Activity should have started")

            // Kill self
            Process.killProcess(Process.myPid())
        }
    }

    fun export(): ByteArray? {
        if (exportFolder == null) {
            return null
        }
        val output = ZipFile()
        val files = exportFolder.listFiles()
        for (file in files!!) {
            output.addFile(file.name, file)
        }
        return output.toByteArray()
    }

    fun clearExports() {
        if (exportFolder == null) {
            return
        }
        val files = exportFolder.listFiles()
        for (file in files!!) {
            file.delete()
        }
    }

    private fun exportData(data: String, now: Long) {
        if (exportFolder == null) {
            return
        }
        @SuppressLint("SimpleDateFormat")
        val sdf = SimpleDateFormat("yyyy-MM-dd'T'HH-mm-ss.SSS")
        sdf.timeZone = TimeZone.getTimeZone("CET")
        val filename = sdf.format(Date(now))
        if (!exportFolder.exists()) {
            exportFolder.mkdirs()
        }
        if (!exportFolder.isDirectory) {
            Log.e(
                "CrashHandler",
                "Cannot export the crash logs to a file due to the folder not being a folder"
            )
            return
        }
        val out = File(exportFolder, "$filename.log")
        out.writeText(data, Charsets.UTF_8)
        Log.d("CrashHandler", "Saving file to ${out.absolutePath}")
    }

    /**
     * build the data text
     * @param now the date as of right now
     * @param previousCrash the previous crash date
     * @param thread the thread that crashed
     * @param throwable the exception thrown
     *
     * @return the string that contains a nicely formatted list of informations about the device
     */
    private fun buildData(
        now: Long,
        previousCrash: Long?,
        thread: Thread,
        throwable: Throwable
    ): String {
        val app = application

        if (app == null) {
            return "Could not build data because the library is missing the context"
        }

        // prepare to build debug string
        var data = "${app.getString(R.string.crash_handler_crash_report)}\n\n"

        // add the user submitted prefix
        data += prefix ?: ""

        // add device informations
        val deviceToReport =
            if (Build.DEVICE.contains(Build.MANUFACTURER)) {
                Build.DEVICE
            } else {
                "${Build.MANUFACTURER} ${Build.DEVICE}"
            }

        // add the device informations
        data += "\n\n${app.getString(
            R.string.crash_handler_hard_soft_infos,
            deviceToReport,
            Build.MODEL,
            Build.VERSION.RELEASE,
            Build.VERSION.SDK_INT
        )}"

        // add the current time to it
        data += "\n\n${app.getString(
            R.string.crash_handler_crash_happened,
            Date(now).toString()
        )}"

        // add the previous crash date if available
        if (previousCrash != null) {
            data += "\n${app.getString(
                R.string.crash_handler_previous_crash,
                Date(previousCrash).toString()
            )}"
        }

        // get Thread name and ID
        data += "\n\n${app.getString(
            R.string.crash_handler_thread_infos,
            thread.name,
            thread.id
        )}"

        // print exception backtrace
        data += "\n\n${app.getString(R.string.crash_handler_error)}\n${throwable.stackTraceToString()}\n\n"

        data += "Generated by Dzeio Crash Handler Version ${BuildConfig.VERSION}\n\n"

        // add the user submitted suffix
        data += suffix ?: ""

        return data
    }
}
